## 目录
```
### 第1 章 组件化开发与composer 使用……………………………………………… 1
#### 1.1 组件化开发… ……………………………………………………………………… 1
#### 1.2 composer 使用……………………………………………………………………… 2
* 1.2.1 composer 安装 ………………………………………………………………………… 2
* 1.2.2 组件安装 ……………………………………………………………………………… 5
* 1.2.3 自动加载 ……………………………………………………………………………… 6
* 1.2.4 composer 命令行简介 ………………………………………………………………… 7
#### 1.3 手动构建Laravel 框架……………………………………………………………… 8
* 1.3.1 项目初始化 …………………………………………………………………………… 8
* 1.3.2 添加路由组件 ………………………………………………………………………… 9
* 1.3.3 添加控制器模块 …………………………………………………………………… 12
* 1.3.4 添加模型组件 ……………………………………………………………………… 13
* 1.3.5 添加视图组件 ……………………………………………………………………… 17
```

## 第1 章 组件化开发与composer 使用……………………………………………… 1
* 组件化开发 / IoC 容器技术 / 分布式应用架构设计

### 1.1 组件化开发… ……………………………………………………………………… 1
* PHP-FIG(PHP Framework Interop Group, PHP 框架互动组织):
    * www.php-fig.org
    * 制定了一系列 PHP 开发的规范 (PSR 编码规范标准)
    * TODO: PSR 标准补充:

* Laravel 的底层使用了很多 Symfony 框架中的组件


### 1.2 composer 使用……………………………………………………………………… 2
* composer 是什么:
    * PHP 的组件化管理工具

#### 1.2.1 composer 安装 ………………………………………………………………………… 2
* 官网: www.getcomposer.org

* 安装: 不介绍, 自己上官网

* 源: composer 源改为国内最好, 知道有这个配置即可, 具体自行搜索

#### 1.2.2 组件安装 ……………………………………………………………………………… 5
* 组件资源库: packagist.org

* eg: 在项目的根目录下创建 composer.json 文件
```json
{
    // 项目名 (非必需, 如果作为资源包发布就需要)
    "name": "glow/model-test",
    // 需要的资源包
    "require": {
        // 包名和版本
        "monolog/monolog": "1.0.*"
    }
}
```

* composer 包的版本控制:
    * 确切版本号: `1.1.1`
    * 范围版本号: `>=1.1` OR `<2.3`
    * 通配符版本号: `1.0.*` (用于匹配 `>=1.0` 且 `<1.1` 的版本)
    * 赋值运算版本号: `~1.0` (用于匹配 `>=1.0` 且 `<2.0` 的版本)

* `composer install`:
    * 安装 composer.json 指定的组件, 下载到当前目录的 `vendor` 文件夹下;
    * 目录结构例如 `vendor\monolog\monolog`
    * 完成组件下载后会创建一个 `composer.lock` 锁文件:
        * 该文件记录当前项目以来组件的确切版本号, 当(其他人)执行 `composer install` 的时候会先查看此文件中的版本, 如果存在则下载文件中指定的版本;
        * `composer.lock` 文件需要添加到版本库, 这点对分布式开发非常用用, 实现程序的版本统一;

* `composer update`:
    * 有组件要更新版本使用该命令
    * TODO: 补充如何升级指定包的命令

#### 1.2.3 自动加载 ……………………………………………………………………………… 6
* `vendor` 目录下提供一个自动加载文件: `vendor/autoload.php`
    * 项目中 require 此文件即可使所有下载的组件实现自动加载

* 实现文件自动加载的四种规范形式:
    * PSR-0 (TODO:好像已经确定废弃了)
    * PSR-4 (**推荐**)
    * classmap
    * file

#### 1.2.4 composer 命令行简介 ………………………………………………………………… 7
* composer 工具常用命令功能:
    * composer list
    * composer init
    * composer install
    * composer update
    * composer require
    * composer search
    * composer show
    * composer validate         检测 composer.json 文件是否有效
    * composer self-update
    * composer create-project   基于 composer 创建一个新的项目
    * composer dump-autoload    在添加新的类和目录映射时更新 autoloader

### 1.3 手动构建Laravel 框架……………………………………………………………… 8
* 搭建类似 laravel 服务端程序框架

#### 1.3.1 项目初始化 …………………………………………………………………………… 8
* 创建 composer.json 文件

* 引用对应的依赖包, 执行 `composer update`

#### 1.3.2 添加路由组件 ………………………………………………………………………… 9
* 组件 `illuminate/routing`
    * 注意该组件也会有个 "composer.json" 文件, 记录该组件所依赖的其他组件(`symfony/routing` 和 `illuminate/container` 等)

* 组件 `illuminate/events`
    * TODO: 该组件的作用

* 流程: 自动加载函数 服务容器实例化 与 服务注册 路由加载 请求实例化 路由分发 响应生成与发送.

* 服务容器:
    * laravel 框架中的一些功能的生成都需要服务容器来实现, 即 `Illuminate\Container\Container` 类的实例
    * 服务容器用于解析服务注册和解析, 也就是说向服务容器注册能够实现某些功能的实例或会调函数, 当需要时从服务容器中获取相应的实例

#### 1.3.3 添加控制器模块 …………………………………………………………………… 12


#### 1.3.4 添加模型组件 ……………………………………………………………………… 13


#### 1.3.5 添加视图组件 ……………………………………………………………………… 17

