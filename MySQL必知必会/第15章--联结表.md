## 目录
```
### 第15章 联结表 ............................97
#### 15.1 联结.....................................97
* 15.1.1 关系表 ..................97
* 15.1.2 为什么要使用联结......................99
#### 15.2 创建联结 .............................99
* 15.2.1 WHERE子句的重要性....................100
* 15.2.2 内部联结 ............103
* 15.2.3 联结多个表 ........104
### 15.3 小结...................................105
```


## 第15章 联结表 ............................97
* 使用联结的 SELECT 语句

### 15.1 联结.....................................97
* SQL最强大的功能之一就是能在数据检索查询的执行中联结（join）表

#### 15.1.1 关系表 ..................97
* **外键（foreign key）**: 外键为某个表中的一列，它包含另一个表的主键值，定义了 *两个表之间的关系*

* **可伸缩性（scale）**: 能够适应不断增加的工作量而不失败

#### 15.1.2 为什么要使用联结......................99


### 15.2 创建联结 .............................99
* 联结的创建非常简单，规定要联结的所有表以及它们如何关联即可:
```mysql
SELECT vend_name, prod_name, prod_price
FROM vendors, products
WHERE vendors.vend_id = products.vend_id
ORDER BY vend_name, prod_name;

# WHERE 子句指示 MySQL 匹配 vendors 表中的 vend_id 和 products 表中的 vend_id
```

* 完全限定列名 在引用的列可能出现二义性时，必须使用 **完全限定列名**（用一个点分隔的表名和列名）

#### 15.2.1 WHERE子句的重要性....................100
* **笛卡儿积（cartesian product）** 由没有联结条件的表关系返回的结果为笛卡儿积
```
SELECT vend_name, prod_name, prod_price
FROM vendors, products; 
# 移除 where 条件你就能看到 **笛卡儿积** (WHERE 条件就是用来过滤掉不正确的条件)
```

* **不要忘了WHERE子句**
    * 应该保证所有联结都有 WHERE 子句，否则 MySQL 将返回比想要的数据多得多的数据;
    * 同理，应该保证 WHERE 子句的正确性, 不正确的过滤条件将导致 MySQL 返回不正确的数据;

* **叉联结**
    * 有时我们会听到返回称为 **叉联结（cross join）** 的笛卡儿积的联结类型

#### 15.2.2 内部联结 ............103
* 目前为止所用的联结称为 **等值联结（equijoin）**，它基于两个表之间的相等测试。
    * 这种联结也称为 **内部联结(inner join?)**

* INNER JOIN ON:
```mysql
SELECT vend_name, prod_name, prod_price
FROM vendors INNER JOIN products
ON vendors.vend_id = products.vend_id
ORDER BY vend_name, prod_name;
```
* 分析: 
    * 此语句中的 SELECT 与前面的 SELECT 语句相同，但 FROM 子句不同。
    * 这里，两个表之间的关系是 FROM 子句的组成部分，以 INNER JOIN 指定。
    * 在使用这种语法时，联结条件用特定的 ON 子句而不是 WHERE 子句给出。
    * 传递给 ON 的实际条件与传递给 WHERE 的相同。

#### 15.2.3 联结多个表 ........104
* 继续逗号分割或者 INNER JOIN

* **性能考虑**
> MySQL在运行时关联指定的每个表以处理联结。这种处理可能是非常耗费资源的，因此应该仔细，不要联结不必要的表。联结的表越多，性能下降越厉害

* 比如拆分成多个子查询

## 15.3 小结...................................105