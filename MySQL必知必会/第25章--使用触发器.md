## 目录
```
### 第25章 使用触发器 .................181
#### 25.1 触发器...............................181
#### 25.2 创建触发器 .......................182
#### 25.3 删除触发器 .......................183
#### 25.4 使用触发器 .......................183
* 25.4.1 INSERT触发器....183
* 25.4.2 DELETE触发器....184
* 25.4.3 UPDATE触发器....185
* 25.4.4 关于触发器的进一步介绍 ............186
### 25.5 小结...................................186
```


## 第25章 使用触发器 .................181
### 25.1 触发器...............................181
* 但是，如果你想要某条语句（或某些语句）在事件发生时自动执行

* 例如:
    * 每当增加一个顾客到某个数据库表时，都检查其电话号码格式是否正确，州的缩写是否为大写;
    * 每当订购一个产品时，都从库存数量中减去订购的数量;
    * 无论何时删除一行，都在某个存档表中保留一个副本.

* **触发器** 是 MySQL 响应以下任意语句而自动执行的一条 MySQL语句（或位于 BEGIN 和 END 语句之间的一组语句）:
    * DELETE;
    * INSERT;
    * UPDATE.

### 25.2 创建触发器 .......................182
* 在创建触发器时，需要给出 4 条信息：
    * 唯一的触发器名；
    * 触发器关联的表；
    * 触发器应该响应的活动（DELETE、INSERT或UPDATE）；
    * 触发器何时执行（处理之前或之后）。

* **保持每个数据库的触发器名唯一**

* 触发器用 `CREATE TRIGGER` 语句创建
* eg:
```mysql
CREATE TRIGGER newproduct AFTER INSERT ON products
FOR EACH ROW SELECT 'Product added';
```

* **仅支持表** 只有表才支持触发器，视图不支持（临时表也不支持）:
    * 触发器按每个表每个事件每次地定义，每个表每个事件每次只允许一个触发器;
    
    * 因此，每个表最多支持 6 个触发器（每条 INSERT、UPDATE 和 DELETE 的之前和之后）;
    
    * 单一触发器不能与多个事件或多个表关联，所以，如果你需要一个对 INSERT 和 UPDATE 操作执行的触发器，则应该定义两个触发器

* **触发器失败**
    * 如果BEFORE触发器失败，则MySQL将不执行请求的操作。
    * 此外，如果BEFORE触发器或语句本身失败，MySQL将不执行AFTER触发器（如果有的话）。

### 25.3 删除触发器 .......................183
* `DROP TRIGGER xxx;`
    * 触发器不能更新或覆盖。为了修改一个触发器，必须先删除它，然后再重新创建。
    
### 25.4 使用触发器 .......................183

#### 25.4.1 INSERT触发器....183
* INSERT 触发器在 INSERT 语句执行 *之前或之后执行*, 需要知道以下几点：
    * 在 INSERT 触发器代码内，可引用一个名为 NEW 的虚拟表，访问被插入的行;
    * 在 BEFORE INSERT 触发器中，NEW 中的值也可以被更新（允许更改被插入的值）;
    * 对于AUTO_INCREMENT 列，NEW 在 INSERT 执行之前包含 0，在 INSERT 执行之后包含新的自动生成值.

* eg: 创建一个 AFTER INSERT 触发器
```mysql
CREATE TRIGGER neworder AFTER INSERT ON orders
FOR EACH ROW SELECT NEW.order_num;

* 分析: 当你在执行 `INSERT INTO orders ..` 表的操作后会得到 `order_num`
* TODO: 然而我写得却报错了 `[Err] 1415 - Not allowed to return a result set from a trigger`
```

#### 25.4.2 DELETE触发器....184
* DELETE 触发器在 DELETE 语句执行之前或之后执行。需要知道以下两点：
    * 在 DELETE 触发器代码内，你可以引用一个名为 OLD 的虚拟表，访问被删除的行；
    * OLD 中的值全都是只读的，不能更新。

* eg: `CREATE TRIGGER deleteorder BEFORE DELETE ON orders ...`

#### 25.4.3 UPDATE触发器....185
* UPDATE 触发器在 UPDATE 语句执行之前或之后执行。需要知道以下几点：
    * 在 UPDATE 触发器代码中，你可以引用一个名为 OLD 的虚拟表访问以前（UPDATE 语句前）的值，引用一个名为 NEW 虚拟表访问新更新的值;
    * 在 BEFORE UPDATE 触发器中，NEW 中的值可能也被更新（允许更改将要用于 UPDATE 语句中的值）;
    * OLD 中的值全都是只读的，不能更新.

#### 25.4.4 关于触发器的进一步介绍 ............186
* TODO: 看 eg 还是比较有用的一个功能, 但是此书太旧了.

## 25.5 小结...................................186