## 第2章算法 17

### 2.1开场白 18

### 2.2数据结构与算法关系 18

### 2.3两种算法的比较 19
* 经典案例， 高斯计算 1+2+...+100的结果

### 2.4算法定义 20
* __算法__ 是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

### 2.5算法的特性 21
* 输入， 输出， 有穷性， 确定性， 可行性。

#### 2.5.1输入输出 21
* 算法具有零个或多个 __输入__， 至少一个或多个 __输出__

#### 2.5.2有穷性 21
* 算法在执行有限的步骤之后，自动结束而不会无限循环，并且每个步骤在可接受的时间内完成。

#### 2.5.3确定性 21
* 算法的每一步骤都具有明确的含义，不会出现二义性。

#### 2.5.4可行性 21
* 算法的每一步都必须是可行的，也就是说，每一步都能通过执行有限次数完成。


### 2.6算法设计的要求 22
* 正确性， 可读性， 健壮性， 高效率， 存储低

#### 2.6.1正确性 22

#### 2.6.2可读性 23

#### 2.6.3健壮性 23

#### 2.6.4时间效率高和存储量低 23


### 2.7算法效率的度量方法 24
#### 2.7.1事后统计方法 24

#### 2.7.2事前分析估算方法 25


### 2.8函数的渐近增长 27
* __函数的渐近增长__： 给定两个函数 `f(n)` 和 `g(n)`，如果存在一个整数 `N`，使得对于所有的 `n > N`，`f(n)`总是比 `g(n)` 大，那么，我们说 `f(n)` 的渐近增长快于 `g(n)`。
    * 例如：`f(n) = 2n^2+1，g(n) = 2n+1`, 当 `n=1` 是 `f(n) = g(n)`，这个时候对应上面的概念，`N=1`，当 `n>N`，也就是当 `n>1` 时，`f(n) > g(n)`，所以，我们说 `f(n)` 的 __渐近增长__ 快于`g(n)`, 同理，我们可以观察 `2n` 与 `2n^2`

* 判断一个算法的效率，函数中的常量和其他次要项常常是可以忽略的，更应该关注主项（最高阶项）的阶数。

* 某个算法，随着 n 的增大，它会越来越优于另一个算法，或者越来越差与另一个算法。
    * 通过 __算法时间复杂度__ 来估算算法的 __时间效率__

### 2.9算法时间复杂度 29
#### 2.9.1算法时间复杂度定义 29

#### 2.9.2推导大o阶方法 30

#### 2.9.3常数阶 30

#### 2.9.4线性阶 31

#### 2.9.5对数阶 32

#### 2.9.6平方阶 32

#### 2.10常见的时间复杂度 35

#### 2.11最坏情况与平均情况 35

#### 2.12算法空间复杂度 36

#### 2.13总结回顾 37

#### 2.14结尾语 38
